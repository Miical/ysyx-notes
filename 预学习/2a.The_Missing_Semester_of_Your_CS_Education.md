以前刷过一遍，在此只记录生疏部分以及课后题。

# 课程概览与 shell
课程地址：[课程概览与 shell · the missing semester of your cs education](https://missing-semester-cn.github.io/2020/course-shell/)
## 讲义
涉及命令：
- 使用shell `date`, `echo`, `which`
- 在shell中导航 `pwd`, `cd`, `ls`
- 创建连接 `<`, `>`, `|`, `>>`

## 课后练习

1. 本课程需要使用类Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用[Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/)或者是 Linux 虚拟机。使用`echo $SHELL`命令可以查看您的 shell 是否满足要求。如果打印结果为`/bin/bash`或`/usr/bin/zsh`则是可以的。
	
	```shell
	miical@Miicals-Ubuntu ~/ysyx-workbench/nemu$ echo $SHELL
	/usr/bin/zsh
	```
	
2. 在 `/tmp` 下新建一个名为 `missing` 的文件夹。
	
	```shell
	miical@Miicals-Ubuntu /tmp$ mkdir missing
	```
	
3. 用 `man` 查看程序 `touch` 的使用手册。
	
	```shell
	miical@Miicals-Ubuntu ~$ man touch
	```
	
4. 用 `touch` 在 `missing` 文件夹中新建一个叫 `semester` 的文件。
	
	```shell
	miical@Miicals-Ubuntu /tmp/missing$ touch semester
	```
	
5. 将以下内容一行一行地写入 `semester` 文件：
    
    ```
     #!/bin/sh
     curl --head --silent https://missing.csail.mit.edu
    ```
    
    第一行可能有点棘手， `#` 在Bash中表示注释，而 `!` 即使被双引号（`"`）包裹也具有特殊的含义。 单引号（`'`）则不一样，此处利用这一点解决输入问题。更多信息请参考  [Bash quoting 手册](https://www.gnu.org/software/bash/manual/html_node/Quoting.html)
	
	```shell
	miical@Miicals-Ubuntu /tmp/missing$ echo '#!/bin/sh' >> semester 
	miical@Miicals-Ubuntu /tmp/missing$ echo 'curl --head --silent https://missing.csail.mit.edu' >> semester 
	miical@Miicals-Ubuntu /tmp/missing$ cat semester
	#!/bin/sh
	curl --head --silent https://missing.csail.mit.edu
	```
	
6. 尝试执行这个文件。例如，将该脚本的路径（`./semester`）输入到您的shell中并回车。如果程序无法执行，请使用 `ls` 命令来获取信息并理解其不能执行的原因。
	
	```shell
	miical@Miicals-Ubuntu /tmp/missing$ ./semester                       
	zsh: permission denied: ./semester
	miical@Miicals-Ubuntu /tmp/missing$ ls -l
	total 4
	-rw-rw-r-- 1 miical miical 61 Nov  4 10:56 semester
	```
	
	无执行权限
	
7. 查看 `chmod` 的手册(例如，使用 `man chmod` 命令)
	
	```shell
	miical@Miicals-Ubuntu /tmp/missing$ man chmod
	```
	
8. 使用 `chmod` 命令改变权限，使 `./semester` 能够成功执行，不要使用 `sh semester` 来执行该程序。您的 shell 是如何知晓这个文件需要使用 `sh` 来解析呢？更多信息请参考：[shebang](https://en.wikipedia.org/wiki/Shebang_(Unix))
	
	```shell
	miical@Miicals-Ubuntu /tmp/missing$ chmod u+x semester   
	miical@Miicals-Ubuntu /tmp/missing$ ./semester                      
	HTTP/2 200 
	...
	```
	
9.  使用 `|` 和 `>` ，将 `semester` 文件输出的最后更改日期信息，写入主目录下的 `last-modified.txt` 的文件中
	
	```shell
	miical@Miicals-Ubuntu /tmp/missing$ ./semester | grep "last-modified" > ~/last-modified.txt
	miical@Miicals-Ubuntu /tmp/missing$ cat ~/last-modified.txt
	last-modified: Sat, 14 Oct 2023 12:37:10 GMT
	```
	
10. 写一段命令来从 `/sys` 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。
	
	```shell
	miical@Miicals-Ubuntu /tmp/missing$ cat /sys/class/power_supply/BAT0/capacity
	100
	```
	
# Shell 工具和脚本

## Shell 脚本

本节中，我们会专注于 bash 脚本，因为它最流行，应用更为广泛。

- 为变量赋值 `foo=bar`，访问 `$foo`
- 字符串通过 `'` 和 `"` 分隔符来定义，`'` 定义的字符串为原义字符串，其中的变量不会被转移
- 支持控制流关键字 `if`, `case`, `while`, `for`
- 支持函数

	```bash
	mcd () {
		mkdir -p "$1"
		cd "$1"
	}
	```
 
- 特殊变量
	- `$0` - 脚本名
	- `$1` 到 `$9` - 脚本的参数。 `$1` 是第一个参数，依此类推。
	- `$@` - 所有参数
	- `$#` - 参数个数
	- `$?` - 前一个命令的返回值
	- `$$` - 当前脚本的进程识别码
	- `!!` - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 `sudo !!`再尝试一次。
	- `$_` - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 `Esc` 之后键入 . 来获取这个值
- 命令通常使用 `STDOUT` 来返回输出值，使用 `STDERR` 来返回错误及错误码，便于脚本以更加友好的方式报告错误。
- 退出码可以搭配 `&&`（与操作符）和 `||`（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路[运算符](https://en.wikipedia.org/wiki/Short-circuit_evaluation)（short-circuiting） 同一行的多个命令可以用 `;` 分隔。程序 `true` 的返回码永远是`0`，`false`的返回码永远是`1`。
- **命令替换**：通过 `$( CMD )` 这样的方式来执行`CMD` 这个命令时，它的输出结果会替换掉 `$( CMD )` 。
- **进程替换**： `<( CMD )` 会执行 `CMD` 并将结果输出到一个临时文件中，并将 `<( CMD )` 替换成临时文件名。例如， `diff <(ls foo) <(ls bar)` 会显示文件夹 `foo` 和 `bar` 中文件的区别

**例子**

```bash
#!/bin/bash

echo "Starting program at $(date)" # date会被替换成日期和时间

echo "Running program $0 with $# arguments with pid $$"

for file in "$@"; do
    grep foobar "$file" > /dev/null 2> /dev/null
    # 如果模式没有找到，则grep退出状态为 1
    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息
    if [[ $? -ne 0 ]]; then
        echo "File $file does not have any foobar, adding one"
        echo "# foobar" >> "$file"
    fi
done
```

- **通配符** `?` 和 `*` 用于匹配一个或任意个字符
- 花括号 `{}` 用于自动展开

	```bash
	mv *{.py,.sh} folder
	```

## Shell 工具
### 查看命令如何使用

使用 `-h` 或 `--help` 或 `man`
使用 `tldr`

### 查找文件

```shell
# 查找所有名称为src的文件夹
find . -name src -type d
# 查找所有文件夹路径中包含test的python文件
find . -path '*/test/*.py' -type f
# 查找前一天修改的所有文件
find . -mtime -1
# 查找所有大小在500k至10M的tar.gz文件
find . -size +500k -size -10M -name '*.tar.gz'
```

对文件进行操作

```shell
# 删除全部扩展名为.tmp 的文件
find . -name '*.tmp' -exec rm {} \;
# 查找全部的 PNG 文件并将其转换为 JPG
find . -name '*.png' -exec convert {} {}.jpg \;
```

还可以使用 `fd` 或 `locate`

### 查找代码

`grep` 用于对输入的文本进行匹配

- `-C` 查找结果的上下文
- `-v` 将对结果进行反选
- `-R` 会递归的进入子目录并搜索所有文本文件

出现了很多它的替代品，包括 [ack](https://beyondgrep.com/), [ag](https://github.com/ggreer/the_silver_searcher) 和 [rg](https://github.com/BurntSushi/ripgrep)。

### 查找 shell 命令

- `history | grep find`
- 使用 `Ctrl+R` 进行回溯搜索，反复按下进行切换

### 文件夹导航

- 使用 `ln -s` 创建符号链接
- 使用 `fasd` 和 `autojump`
- 还有一些更复杂的工具可以用来概览目录结构，例如 [`tree`](https://linux.die.net/man/1/tree), [`broot`](https://github.com/Canop/broot) 或更加完整的文件管理器，例如 [`nnn`](https://github.com/jarun/nnn) 或 [`ranger`](https://github.com/ranger/ranger)。

## 课后练习

1. 阅读 [`man ls`](https://man7.org/linux/man-pages/man1/ls.1.html) ，然后使用`ls` 命令进行如下操作：
	- 所有文件（包括隐藏文件）
	- 文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)
	- 文件以最近访问顺序排序
	- 以彩色文本显示输出结果
	 
	```shell
	$ ls -ahtGl 
	```
	 
2. 编写两个bash函数  `marco` 和 `polo` 执行下面的操作。 每当你执行 `marco`时，当前的工作目录应当以某种形式保存，当执行 `polo` 时，无论现在处在什么目录下，都应当 `cd` 回到当时执行 `marco` 的目录。 为了方便debug，你可以把代码写在单独的文件 `marco.sh` 中，并通过 `source marco.sh`命令，（重新）加载函数。
 
	```shell
	marco () {
	  export MARCO_DIR=$(pwd)
	}
	
	polo() {
	  cd "$MARCO_DIR"
	}
	 ```
  
3. 假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。