# RTFSC(3)

源文件组织：

**abstract-machine**
- am **不同架构的AM API实现**
	- include
		- amdev.h
		- am.h *列出了AM中的API*
		- arch
	- Makefile
	- src
		- mips
		- native
		- platform
			- nemu *以NEMU为平台的AM实现*
		- riscv
		- x86
- klib **一些架构无关的库函数**
- Makefile *公用的Makefile规则*
- scripts *构建脚本*


**支撑程序在TRM上运行**：
-  `Area heap` 用于指示堆区的起始和末尾
- `void putch(char ch)` 用于输出一个字符
- `void halt(int code)` 用于结束程序的运行
	- 调用 `nemu_trap()`，宏展开为 `ebreak`
- `void _trm_imit()` 用于进行TRM的相关的初始化工作

# Makefile 解析

## 基本配置和检查 

1. 检查 `MAKECMDGOAL`，若未定义默认image
2. 如果目标不属于 clean, clean-all, html
	1. 检查 `AM_HOME` 是否设置
	2. 检查 `ARCH` 是否合法，并设置好ISA和PLATFORM
	3. 检查 `SRC` 是否定义

```makefile
### Default to create a bare-metal kernel image
ifeq ($(MAKECMDGOALS),)
  MAKECMDGOALS  = image
  .DEFAULT_GOAL = image
endif

### Override checks when `make clean/clean-all/html`
ifeq ($(findstring $(MAKECMDGOALS),clean|clean-all|html),)

### Print build info message
$(info # Building $(NAME)-$(MAKECMDGOALS) [$(ARCH)])

### Check: environment variable `$AM_HOME` looks sane
ifeq ($(wildcard $(AM_HOME)/am/include/am.h),)
  $(error $$AM_HOME must be an AbstractMachine repo)
endif
```

- `MAKECMDGOALS` 可用于获取make的目标
- `findstring` 函数来查找 `MAKECMDGOALS` 中是否包含在这个字符串列表中的任何一个
	- `findstring` 是 Makefile 中的一个函数，用于在字符串中查找子字符串。
	- `$(findstring find,text)`
- `$(info ...)` 函数的作用是在执行 Makefile 时输出一条信息到标准输出
- `wildcard` 是 Makefile 中的一个函数，它用于在 Makefile 规则中查找符合特定模式的文件名或路径
	- `C_FILES := $(wildcard *.c)`

```makefile
## Check: environment variable `$ARCH` must be in the supported list
ARCHS = $(basename $(notdir $(shell ls $(AM_HOME)/scripts/*.mk)))
ifeq ($(filter $(ARCHS), $(ARCH)), )
  $(error Expected $$ARCH in {$(ARCHS)}, Got "$(ARCH)")
endif

### Extract instruction set architecture (`ISA`) and platform from `$ARCH`. Example: `ARCH=x86_64-qemu -> ISA=x86_64; PLATFORM=qemu`
ARCH_SPLIT = $(subst -, ,$(ARCH))
ISA        = $(word 1,$(ARCH_SPLIT))
PLATFORM   = $(word 2,$(ARCH_SPLIT))

### Check if there is something to build
ifeq ($(flavor SRCS), undefined)
  $(error Nothing to build)
endif

### Checks end here
endif
```

- `ARCHS = $(basename $(notdir $(shell ls $(AM_HOME)/scripts/*.mk)))`
	1. **`$(shell ls $(AM_HOME)/scripts/*.mk)`**：这部分使用 `ls` 命令列出了在 `$(AM_HOME)/scripts/` 目录下所有以 `.mk` 结尾的文件。
	2. **`$(notdir ...)`**：接着使用 `notdir` 函数提取了文件列表中的文件名，去除了路径信息，只留下文件的名字和扩展名。
	3. **`$(basename ...)`**：然后使用 `basename` 函数提取了文件名的基本名称，去除了扩展名部分。
- `ifeq ($(filter $(ARCHS), $(ARCH)), )`
	- `$(filter pattern, text)` 用于过滤列表中符合特定条件的元素，返回text中匹配pattern的部分
- `ARCH=x86_64-qemu -> ISA=x86_64; PLATFORM=qemu`
	- `ARCH_SPLIT = $(subst -, ,$(ARCH))`
		- `$(subst from,to,text)`
		- `from` 是要被替换的字符串。
		- `to` 是替换后的字符串。
		- `text` 是要进行替换操作的文本。
	- `ISA        = $(word 1,$(ARCH_SPLIT))`
	- `PLATFORM   = $(word 2,$(ARCH_SPLIT))`
		- `word` 函数，它用于从一个由空格分隔的字符串中提取指定位置的单词。
- `$(flavor variable)` 函数用于获取变量的类型，如果变量未定义，则返回字符串 `undefined`。

## 常规编译目标

1. 创建目标文件夹 
2. 指定编译目标 `INAGE`, `ARCHIVE`
3. 收集需要连接的文件 OBJS, LIBS, LINKAGE

```makefile

### Create the destination directory (`build/$ARCH`)
WORK_DIR  = $(shell pwd)
DST_DIR   = $(WORK_DIR)/build/$(ARCH)
$(shell mkdir -p $(DST_DIR))

### Compilation targets (a binary image or archive)
IMAGE_REL = build/$(NAME)-$(ARCH)
IMAGE     = $(abspath $(IMAGE_REL))
ARCHIVE   = $(WORK_DIR)/build/$(NAME)-$(ARCH).a

### Collect the files to be linked: object files (`.o`) and libraries (`.a`)
OBJS      = $(addprefix $(DST_DIR)/, $(addsuffix .o, $(basename $(SRCS))))
LIBS     := $(sort $(LIBS) am klib) # lazy evaluation ("=") causes infinite recursions
LINKAGE   = $(OBJS) \
  $(addsuffix -$(ARCH).a, $(join \
    $(addsuffix /build/, $(addprefix $(AM_HOME)/, $(LIBS))), \
    $(LIBS) ))
```

**`LINKAGE = $(OBJS) \ ...`**：
- `$(addsuffix /build/, $(addprefix $(AM_HOME)/, $(LIBS)))` 构建了一个路径列表，其中每个库名称加上了路径前缀 `$(AM_HOME)/` 并且添加了 `/build/` 后缀。
- `$(join ...)` 函数将两个列表拼接在一起。
- `$(addsuffix -$(ARCH).a, ...)` 为每个拼接的条目加上特定的后缀 `-$(ARCH).a`。
- `$(OBJS)` 是之前定义的目标文件列表。

## 常规编译选项

```makefile
### (Cross) compilers, e.g., mips-linux-gnu-g++
AS        = $(CROSS_COMPILE)gcc
CC        = $(CROSS_COMPILE)gcc
CXX       = $(CROSS_COMPILE)g++
LD        = $(CROSS_COMPILE)ld
AR        = $(CROSS_COMPILE)ar
OBJDUMP   = $(CROSS_COMPILE)objdump
OBJCOPY   = $(CROSS_COMPILE)objcopy
READELF   = $(CROSS_COMPILE)readelf

### Compilation flags
INC_PATH += $(WORK_DIR)/include $(addsuffix /include/, $(addprefix $(AM_HOME)/, $(LIBS)))
INCFLAGS += $(addprefix -I, $(INC_PATH))

ARCH_H := arch/$(ARCH).h
CFLAGS   += -O2 -MMD -Wall -Werror $(INCFLAGS) \
            -D__ISA__=\"$(ISA)\" -D__ISA_$(shell echo $(ISA) | tr a-z A-Z)__ \
            -D__ARCH__=$(ARCH) -D__ARCH_$(shell echo $(ARCH) | tr a-z A-Z | tr - _) \
            -D__PLATFORM__=$(PLATFORM) -D__PLATFORM_$(shell echo $(PLATFORM) | tr a-z A-Z | tr - _) \
            -DARCH_H=\"$(ARCH_H)\" \
            -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector \
            -Wno-main -U_FORTIFY_SOURCE
CXXFLAGS +=  $(CFLAGS) -ffreestanding -fno-rtti -fno-exceptions
ASFLAGS  += -MMD $(INCFLAGS)
LDFLAGS  += -z noexecstack
```

## 架构相关配置

```makefile
### Paste in arch-specific configurations (e.g., from `scripts/x86_64-qemu.mk`)
-include $(AM_HOME)/scripts/$(ARCH).mk

### Fall back to native gcc/binutils if there is no cross compiler
ifeq ($(wildcard $(shell which $(CC))),)
  $(info #  $(CC) not found; fall back to default gcc and binutils)
  CROSS_COMPILE :=
endif
```

## 编译规则

```makefile
### Rule (compile): a single `.c` -> `.o` (gcc)
$(DST_DIR)/%.o: %.c
	@mkdir -p $(dir $@) && echo + CC $<
	@$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $<)

### Rule (compile): a single `.cc` -> `.o` (g++)
$(DST_DIR)/%.o: %.cc
	@mkdir -p $(dir $@) && echo + CXX $<
	@$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $<)

### Rule (compile): a single `.cpp` -> `.o` (g++)
$(DST_DIR)/%.o: %.cpp
	@mkdir -p $(dir $@) && echo + CXX $<
	@$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $<)

### Rule (compile): a single `.S` -> `.o` (gcc, which preprocesses and calls as)
$(DST_DIR)/%.o: %.S
	@mkdir -p $(dir $@) && echo + AS $<
	@$(AS) $(ASFLAGS) -c -o $@ $(realpath $<)

### Rule (recursive make): build a dependent library (am, klib, ...)
$(LIBS): %:
	@$(MAKE) -s -C $(AM_HOME)/$* archive

### Rule (link): objects (`*.o`) and libraries (`*.a`) -> `IMAGE.elf`, the final ELF binary to be packed into image (ld)
$(IMAGE).elf: $(OBJS) am $(LIBS)
	@echo + LD "->" $(IMAGE_REL).elf
	@$(LD) $(LDFLAGS) -o $(IMAGE).elf --start-group $(LINKAGE) --end-group

### Rule (archive): objects (`*.o`) -> `ARCHIVE.a` (ar)
$(ARCHIVE): $(OBJS)
	@echo + AR "->" $(shell realpath $@ --relative-to .)
	@$(AR) rcs $(ARCHIVE) $(OBJS)

### Rule (`#include` dependencies): paste in `.d` files generated by gcc on `-MMD`
-include $(addprefix $(DST_DIR)/, $(addsuffix .d, $(basename $(SRCS))))
```

- .c -> .o
	- `$(DST_DIR)/%.o: %.c` 定义了一个模式规则。这个规则表明，对于任何在当前目录下的 `.c` 文件，生成的目标文件（`.o` 文件）会放在 `$(DST_DIR)` 目录下。
		- `@mkdir -p $(dir $@) && echo + CC $<`：这个命令会创建生成目标文件的目录（如果目录不存在），并在编译时显示编译器的命令。`$(dir $@)` 提取了目标文件的路径，并使用 `mkdir -p` 命令创建该路径。
		- `@$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $<)`：这是实际的编译命令。它使用了变量 `$(CC)` 中指定的 C 编译器，并应用了一些标志（`$(CFLAGS)`）来编译源文件。`-c` 选项告诉编译器只生成目标文件而不进行链接。`-o $@` 指定了生成的目标文件的名称，`$@` 是自动变量，代表规则的目标文件名。`$(realpath $<)` 获取了目标文件所对应的源文件的真实路径，并作为编译器的输入文件。
	- 这个规则的作用是针对每个 `.c` 文件，使用 C 编译器将其编译成一个对应的目标文件，并将目标文件放在 `$(DST_DIR)` 目录下。

## 其他

```makefile

### Build order control
image: image-dep
archive: $(ARCHIVE)
image-dep: $(OBJS) am $(LIBS)
	@echo \# Creating image [$(ARCH)]
.PHONY: image image-dep archive run $(LIBS)

### Clean a single project (remove `build/`)
clean:
	rm -rf Makefile.html $(WORK_DIR)/build/
.PHONY: clean

### Clean all sub-projects within depth 2 (and ignore errors)
CLEAN_ALL = $(dir $(shell find . -mindepth 2 -name Makefile))
clean-all: $(CLEAN_ALL) clean
$(CLEAN_ALL):
	-@$(MAKE) -s -C $@ clean
.PHONY: clean-all $(CLEAN_ALL)
```



#  通过批处理模式运行NEMU

> 所以在这里我们加一道必做题: 我们之前启动NEMU的时候, 每次都需要手动键入`c`才能运行客户程序. 但如果不是为了使用NEMU中的sdb, 我们其实可以节省`c`的键入. NEMU中实现了一个批处理模式, 可以在启动NEMU之后直接运行客户程序. 请你阅读NEMU的代码并合适地修改Makefile, 使得通过AM的Makefile可以默认启动批处理模式的NEMU.
j

✅  通过批处理模式运行NEMU

```c
NEMUFLAGS += -l $(shell dirname $(IMAGE).elf)/nemu-log.txt -b
```

添加 `-b` 选项即可


# 实现常用的库函数

一种好的做法是把运行时环境分成两部分: 一部分是架构相关的运行时环境, 也就是我们之前介绍的AM; 另一部分是架构无关的运行时环境, 类似`memcpy()`这种常用的函数应该归入这部分, `abstract-machine/klib/`用于收录这些架构无关的库函数. `klib`是`kernel library`的意思, 用于提供一些兼容libc的基础功能.

> 根据需要实现`abstract-machine/klib/src/string.c`中列出的字符串处理函数, 让`cpu-tests`中的测试用例`string`可以成功运行. 关于这些库函数的具体行为, 请务必RTFM.

✅ string 通过测试

实现strcpy, strcat, strcmp, memset, memcmp

![](13%20AM运行时环境.assets/Screenshot%202023-12-19%20at%2020.24.56.png)

> 实现`abstract-machine/klib/src/stdio.c`中的`sprintf()`, 具体行为可以参考`man 3 printf`. 目前你只需要实现`%s`和`%d`就能通过`hello-str`的测试了, 其它功能(包括位宽, 精度等)可以在将来需要的时候再自行实现.

✅ 通过测试 hello-str

![](13%20AM运行时环境.assets/Screenshot%202023-12-19%20at%2021.24.01.png)
# 计算机是个抽象层

| TRM      | 计算       | 内存申请         | 结束运行      | 打印信息            |
| -------- | ---------- | ---------------- | ------------- | ------------------- |
| 运行环境 | -          | malloc()/free()  | -             | printf()            |
| AM API   | -          | heap             | halt()        | putch()             |
| ISA接口  | 指令       | 物理内存地址空间 | nemu_trap指令 | I/O方式             |
| 硬件模块 | 处理器     | 物理内存         | Monitor       | 串口                |
| 电路实现 | cpu_exec() | pmem[]           | nemu_state    | serial_io_handler() |

# 指令环形缓冲区 - iringbuf

